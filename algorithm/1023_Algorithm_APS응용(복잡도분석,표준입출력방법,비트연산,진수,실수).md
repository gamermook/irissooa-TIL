# Algorithm

## SW문제 해결

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의함
3. 어떻게 해결할지 계획을 세움
4. 계획을 검증함
5. 프로그램으로 구현
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아봄



- 문제 해결 전략
  - 직관과 체계적인 접근
- 체계적인 접근 위한 질문들
  - 비슷한 문제를 풀어본 적이 있던가?
  - 단순한 방법에서 시작할 수 있을까?
  - 문제를 단순화 할 수 있을까?
  - 그림으로 그려 볼 수 있을까?
  - 수식으로 표현할 수 있을까?
  - 문제를 분해 할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 특정 형태의 답만을 고려할수 있을까?



## 복잡도 분석

- 알고리즘?
  - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
  - 간단하게 다시 말하면 어떤 문제를 해결하기 위한 절차라고 볼 수 있음
- 알고리즘의 효율
  - 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말함
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말함
    - 효율성을 뒤집어 표현하면 복잡도가 됨
    - 복잡도가 높을수록 효율성은 저하됨
  - 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라짐
      - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
      - 입출력 장비의 성능, 공유여부
    - 소프트웨어 환경에 따라 처리시간이 달라짐
      - 프로그램 언어의 종류
      - 운영체제, 컴파일러의 종류
    - 이러한 환경적차이로 분석이 어렵다

- 복잡도의 점근적 표기
  - 시간(또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.
  - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asympototic Notation)를 사용한다.
  - 입력크기n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
    - Big-Oh 표기
      - (최악의 경우...)
    - Big-Omega표기
      - (잘해봤자...)
    - Big-Theta표기
      - (항상 이만큼...)

### O(Big-Oh)표기

- O-표기는 복잡도의 점근적 상한을 나타낸다.
- 복잡도가 f(n) = 2^(n^2)+7n +4이라면, f(n)의 O-표기는 O(n^2)이다.
- 먼저 f(n)의 단순화된 표현은 n^2이다.
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 c*n^2이 증가함에 따라 f(n)의 상한이 된다(c>0)

![image-20201023143315619](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143315619.png)

- 복잡도 f(n)과 O-표기를 그래프로 나타내고 있다
- n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것 (즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것)을 보여줌

![image-20201023143501363](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143501363.png)



#### 자주사용하는 O-표기

| O-표기   | 뜻                      |
| -------- | ----------------------- |
| O(1)     | 상수시간(Constant time) |
| O(logn)  | 로그(대수)시간          |
| O(n)     | 선형시간                |
| O(nlogn) | 로그 선형 시간          |
| O(n^2)   | 제곱시간                |
| O(n^3)   | 세제곱시간              |
| O(2^n)   | 지수시간                |







### Big-Omega 표기

- 복잡도의 점근적 하한을 의미한다
- f(n)=2^(n^2)-7n+4의 Big-Omega표기는 오메가(n^2)이다.
- f(n)=오메가(n^2)은 'n이 증가함에 따라 2*(n^2)-7n+4'이 cn^2보다 작을 수 없다' 라는 의미이다. 이때 상수 c=1로 놓으면 됨
- O-표기 때와 마찬가지로 오메가-표기도 복잡도 다항식의 최고차항만 계속 없이 취하면 된다.
- ***"최소한 이만한 시간은 걸린다."***

- 복잡도 f(n)과 오메가-표기를 그래프로 나타낸 것인데, n이 증가함에 따라 오메가(g(n))이 점근적 하한이라는 것 (즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 작다는 것)을 보여줌 

![image-20201023143834164](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023143834164.png)



### Theta-표기

- O-표기와 오메가-표기가 같은 경우에 사용

- f(n)= 2*(n^2) + 8n + 3 = O(n^2)=오메가(n^2)이므로, f(n)=theta(n^2)이다.

- 'f(n)은 n이 증가함에 따라 ***n^2과 동일한 증가율을 가진다***라는 의미

  

![image-20201023144038263](1023_Algorithm_APS응용(복잡도분석,표준입출력방법,비트연산,진수,실수).assets/image-20201023144038263.png)



### 왜 효율적인 알고리즘이 필요한가?

- 10억개의 숫자를 정렬하는데 PC에서 O(n^2)알고리즘은 300여년이 걸리는 것을 반년에 O(nlogn) 알고리즘은 5분만에 정렬됨
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.



## 표준 입출력 방법

- 출력
  - print()
    - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  - print('text',end='')
    - 출력 시 마지막에 개행문자 제외할 시
  - print('%d'% number)
    - Formatting된 출력
- 파일의 내용을 표준 입력으로 읽어오는 방법
  - import sys
  - sys.stdin = open('a.txt','r')



## 비트연산

- 비트연산자

| 비트연산자 | 연산자의 기능                                      |
| ---------- | -------------------------------------------------- |
| `&`        | 비트단위로 AND연산을 한다                          |
| `|`        | 비트단위로 OR연산을 한다                           |
| `^`        | 비트단위로 XOR연산을 한다.(같으면 0  다르면 1)     |
| `~`        | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
| `<<`       | 피연산자의 비트 열을 왼쪽으로 이동시킨다.          |
| `>>`       | 피연산자의 비트 열을 오른쪽으로 이동시킨다.        |

- `1<<n`
  - 2^n의 값을 갖는다.
  - 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
  - Power set(모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.
- `i & (1 << j)`
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미함