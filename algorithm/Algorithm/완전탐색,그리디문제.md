## 완전탐색,그리디

[toc]

## 2003_수들의합2

> [2003_수들의합2](https://www.acmicpc.net/problem/2003)  
>
> ### **투포인터 알고리즘**
>
> [참고](https://velog.io/@koyo/python-two-pointer)
>
> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘
>
> 예를 들면, 학생 40명이 순서대로 일렬로 세워져 있는 경우, 1번부터 10번까지 라고 부르듯 시작점과 끝점 2개의 점을 통해 데이터의 범위를 표현할 수 있다.
>
> #### 1. '특정한 합을 가지는 부분 연속 수열'문제에 적용가능
>
> ```python
> n = 5 # 데이터의 개수 N
> m = 5 # 찾고자 하는 부분합 M
> data = [1, 2, 3, 2, 5] # 전체 수열
> 
> count = 0
> interval_sum = 0
> end = 0
> 
> # start를 차례대로 증가시키며 반복
> for start in range(n):
>  # end 를 가능한 만큼 이동시키기
>  while interval_sum < m and end < n:
>      interval_sum += data[end]
>      end += 1
>  # 부분합이 m일 때 카운트 증가
>  if interval_sum == m:
>      count += 1
>  interval_sum -= data[start]
>  
> print(count) # 3
> ```
>
> #### 2. 정렬되어 있는 두 리스트의 합집합에도 활용할 수 있다.
>
> 이는 병렬정렬(Merge Sort)의 Conquer영역의 기초가 되기도 한다.
>
> 다음과 같다.
>
> 1. 정렬된 리스트 A와 B를 입력받는다.
> 2. 리스트 A에서 처리되지 않은 원소 중 가장 작은 원소를 i가 가리키도록 한다.
> 3. 리스트 B에서 처리되지 않은 원소 중 가장 작은 원소를 j가 가리키도록 한다.
> 4. A[i]와 B[j]중에서 더 작은 원소를 결과 리스트에 담는다.
> 5. 리스트 A와 B에서 더 이상 처리할 원소가 없을 때까지 2~4번 과정을 반복한다.
>
> ```python
> # 사전에 정렬된 리스트 A와 B 선언
> n, m = 3, 4
> a = [1, 3, 5]
> b = [2, 4, 6, 8]
> 
> # 리스트 A와 B의 모든 원소를 담을 수 있는 크기의 결과 리스트 초기화
> result = [0] * (n + m)
> i = 0
> j = 0
> k = 0
> 
> # 모든 원소가 결과 리스트에 담길 때까지 반복
> while i < n or j < m:
>     # 리스트 B의 모든 원소가 처리되었으나,리스트 A의 원소가 더 작을 때
>     if j >= m or (i < n and a[i] <= b[j]):
>         # 리스트 A의 원소를 결과 리스트로 옮기기
>         result[k] = a[i]
>         i += 1
>     # 리스트 A의 모든 원소가 처리되었거나, 리스트 B의 원소가 더 작을 때
>     else:
>         # 리스트 B의 원소를 결과 리스트로 옮기기
>         result[k] = b[j]
>         j += 1
>     k += 1
>     
> # 결과 리스트 출력
> for i in result:
>     print(i, end=' ') # 1 2 3 4 5 6 8
> ```

- 처음에는 완전탐색으로 풀었다. -> 시간초과! 하나하나 다 살펴보기엔 너무 시간이 많이든다.

```python
N,M= map(int,input().split())
nums = list(map(int,input().split()))
# print(nums)
cnt = 0
for i in range(N):
    total = 0
    for j in range(i,N):
        # print(j)
        total += nums[j]
        if total == M:
            cnt+=1
            break
print(cnt)
```

- 투포인터 알고리즘으로 풀어봤다.

> 이 알고리즘은 부분합을 구할 때 많이 이용되고 다른 문제에도 응용되니까 잘 익혀두자

```python
'''
처음에는 완전탐색으로 풀었는데 시간초과가 남
찾아보니까 '투포인터 알고리즘'을 이용함!
'''

#수열의 개수N, 찾고자하는 부분합M
N,M= map(int,input().split())
#수열리스트
nums = list(map(int,input().split()))
# print(nums)
cnt = 0
interval_sum=0
end = 0
#start를 차례대로 증가시키며 반복
for start in range(N):
    #end를 가능한만큼 이동시키기
    while interval_sum < M and end < N:
        interval_sum += nums[end]
        end += 1
    #부분집합 M일때 카운트 증가
    if interval_sum == M:
        cnt+=1
    #end가 멀어질때 제일 앞의 수를 뺴면서 합을 구함
    interval_sum -= nums[start]
print(cnt)
```

- 투포인터는 시간을 줄이려고 하는건데 위에 풀이는 심하면 n^2이 됨! 그래서 아래와같이 풀어야됨

```python
N, M = map(int,input().split())
arr = list(map(int,input().split()))
start = end = hab = ans = 0
while True:
    if hab == M:
        #print(start,end)
        ans += 1
    if hab >= M:
        hab -= arr[start]
        start += 1
    elif end == N:
        break
    elif hab < M:
        hab += arr[end]
        end += 1
print(ans)
```



## 1182_부분수열의 합

```python
'''
num_list에서 수의 부분집합 중 더해서 합이 S가 되는 경우의 수 출력!
부분집합 구하는 함수 만들고,
그 sel의 합이 S인 것!
'''

import sys
sys.setrecursionlimit(10**8)
sys.stdin = open('input.txt','r')

def powerset(idx):
    global cnt
    #idx가 끝까지 갔으니 부분집합 조건 확인
    if idx == N:
        #부분집합 합을 구할 변수
        total = 0
        for i in range(N):
            #부분집합 포함 표시가 있다면
            if sel[i]:
                total += num_list[i]
        #해당 부분집합 합이 S라면! 그리고 공집합이 아니라면!(S가 0일수도 있어서)
        if sum(sel) and total == S:
            cnt += 1
        return
    #포함
    sel[idx] = 1
    powerset(idx+1)
    #포함안함
    sel[idx] = 0
    powerset(idx+1)

#정수의 개수, 정수S
N,S = map(int,input().split())

#N개의 정수
num_list = list(map(int,input().split()))

#부분집합을 표시할 변수
sel = [0]*N
#합이 S인 부분집합 개수를 세어줄 변수
cnt = 0
powerset(0)
print(cnt)
```



## BOJ_1931_회의실배정

> [BOJ_1931_회의실배정](https://www.acmicpc.net/problem/1931)

```python
'''
방문배열을 만들어서
회의 시작시간~끝나는 시간에 표시해줌!
표시한 뒤, ans = []에 넣어줌
for문을 돌리는데 ans의 첫값부터 선택했다고 했을 떄 그다음 선택은 종료시간보다 같거나 커야됨! 그렇게 수를 세고 MAX갱신
'''

import sys
sys.stdin = open('input.txt','r')

#회의 수
N = int(input())
#회의 정보
conf = []
final = 0
for i in range(N):
    #시작시간, 끝나는시간
    start, end = map(int,input().split())
    conf.append([start,end])

#끝나는 시간이 빠른 순으로 정렬하고, 제일 처음 것을 선택한뒤, 그다음부터는
# print(conf)
# conf.sort(key=lambda x:(x[1],x[0]))
# print(conf)
s,e = conf[0]
cnt = 1
for c in range(1,len(conf)):
    if conf[c][0] >= e:
        # print(conf[c])
        cnt += 1
        s,e = conf[c]
print(cnt)
```



## BOJ_2875_대회or인턴

> [BOJ_2875_대회or인턴](https://www.acmicpc.net/problem/2875)

```python 
'''
1. 여2 남1로 구성된 최대로 만들 수 있는 팀을 구함
2. K명을 한팀에서 빼오고 만약 한팀이상 필요하면 다음 팀에서 빼옴
'''
N,M,K = map(int,input().split())
cnt= 0
total = N + M
while N > 1 and M > 0:
    N -= 2
    M -= 1
    cnt += 1
# print(cnt)
total -= cnt*3
#K가 1팀보다 수가 적으면 그 팀만 뻄
while K > 0:
    if total > 0:
        total -=1
        K -=1
    else:
        cnt-=1
        K-=3
print(cnt)
```



## BOJ_1476_날짜계산

> [BOJ_1476_날짜계산](https://www.acmicpc.net/problem/1476)

```python
import sys
sys.stdin = open('input.txt','r')

def check(E,S,M):
    if E == S and S == M:
        return True
    return False

# T = int(input())
# for tc in range(1,T+1):
E,S,M = map(int,input().split())

while not check(E,S,M):
    if S > E:
        E += 15
    else:
        S += 28
    if check(E,S,M):
        break
    if M > E:
        E += 15
    else:
        M += 19
print(E)
```



## BOJ_10819_차이를최대로

> [BOJ_10819_차이를최대로](https://www.acmicpc.net/problem/10819)

```python
def perm(idx,n):
    global MAX
    if idx == N:
        # print(sel)
        SUM = 0
        for a in range(0, len(A) - 1):
            SUM += abs(sel[a] - sel[a + 1])
        if SUM > MAX:
            MAX = SUM
        return MAX
    for i in range(N):
        if u[i] == 0:
            u[i] = 1
            sel[idx] = A[i]
            perm(idx+1,n)
            u[i] = 0

N = int(input())
A = list(map(int,input().split()))
sel = [0]*N
u = [0]*N
# selectSort(A,0)
MAX = 0
perm(0,N)
# print(A)

print(MAX)

```

처음엔...

1. 선택정렬로 제일 앞에 제일 큰수, 2번쨰는 제일 작은수를 골라서 정렬
   그렇게 0,1idx가 정해지고 그다음 2 idx부터 1번 반복
2. 정렬시킨 뒤, 뻬주고 절댓값!(abs이용)

선택정렬로 생각하고 풀었었는데...순열로 나올수 있는 원소의 위치를 모두 구한뒤, 규칙에 따른 값이 최대인값을 구하는 문제였다..ㅠ

```python
import sys
sys.stdin = open('input.txt','r')

def selectSort(arr,idx):
    if idx == len(arr)-2:
        if arr[idx] < arr[idx+1]:
            arr[idx],arr[idx+1] = arr[idx+1],arr[idx]
        return
    MIN,MAX = idx+1,idx
    for i in range(idx+2,len(arr)):
        # print(idx,A,i,arr[MAX],arr[i],arr[MIN])
        if arr[i] > arr[MAX]:
            MAX = i
            # print('MAX',MAX)
        if arr[i] < arr[MIN]:
            MIN = i
            # print('MIN',MIN)
    arr[MAX], arr[idx] = arr[idx], arr[MAX]
    arr[MIN], arr[idx+1] = arr[idx+1],arr[MIN]
    selectSort(arr,idx+2)
```



## SWEA_5203_베이비진게임

> [SWEA_5203_베이비진게임](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

```python
'''
0부터 9까지인 숫자 카드 4세트를 섞은 후 6개의 카드를 골랐을 때,
연속인 숫자가 3개 이상이면 run, 같은 숫자가 3개 이상이면 triplet이라고 한다.
6장의 카드가 run과 triplet으로만 이루어진 것을 babyginㅇ리ㅏ고 함
babygin인지 판단하는 프로그램
여기서는 6장 되기전에 먼저 run이나 triplet이 되는 사람이 승자가됨!
두 사람이 가져가게 되는 순서대로 12장의 카드에 대한 정보가 주어졌을 때 승자를 알아내는 프로그램작성
무승부인 경우 0을 출력

#1. babygin인지 체크하는 함수만들기
인자로 준 list를 0~9까지 수를 cnt하고, 같은수가 3개 이상 있는지, 연속하는수 3개이상 있는지 확인

#2. 플레이어 1과 2가 뽑은 카드가 순서대로 list에 append되면서 계속 체크를 함!
#3. 만약에 6장을 채우기 전에 먼저 run이나 triplet이 나오면 승자 출력,
#4. 모두 가져갈때까지 run이나 triplet이 없으면 무승부 0

'''
import sys
sys.stdin = open('input.txt','r')
def check(arr):
    #0~9의수를 세고 담을 cnt배열
    numbers = [0]*10
    for i in arr:
        numbers[i] += 1
    # print(numbers)
    cnt = 0
    for n in range(10):
        #같은 수 3개 이상 있으면 True
        if numbers[n] >= 3:
            return True
        #연속된 수 3개 이상 있으면 True
        if numbers[n]:
            cnt+=1
        else:
            cnt = 0
        if cnt >=3:
            return True
    return False



T = int(input())
for tc in range(1,T+1):
    cards = list(map(int,input().split()))
    one= []
    two = []
    #카드를 1과2가 번갈아가면서 뽑음
    for c in range(len(cards)):
        #2가뽑을 카드
        if c %2:
            two.append(cards[c])

        #1이 뽑을 카드
        else:
            one.append(cards[c])

        if check(one):
            print('#{} 1'.format(tc))
            break
        if check(two):
            print('#{} 2'.format(tc))
            break
    #아니라면 무승부! 0 출력력
    else:
        print('#{} 0'.format(tc))
```

